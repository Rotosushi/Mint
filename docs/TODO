// Copyright (C) 2023 Cade Weinberg
// 
// This file is part of Mint.
// 
// Mint is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Mint is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Mint.  If not, see <http://www.gnu.org/licenses/>.

What do we want to accomplish next?

well, I have two goals for the language,
one is to learn more about PL's and PL features.
  the what, how, why, and the fitting together.

two is to have something to play around with.

for point one, I am currently interested in:
memory allocators,
compile time evaluation,
compiling a source file,
use-before-definition,
lambdas,
algebraic data types (and/or tagged unions and structs/tuples),
pattern matching,
macros,
embedding the language interpreter itself into executables as a scripting language.
at comptime the compiler interprets nearly all expressions,
(other than runtime dependent expressions)
and then from the interpreted input an executable is generated.

needs testing:
  Modules,



crazy ideas:
functions can have their return type deduced right?
well, what if we computed that deduction as a union
(or tagged union, or algebraic data type) of all types 
being used as return values. Thus, the common success path 
error path of the function could be deduced by what 
error types and success types the function body returns.
then since the return type of the function is now a composite 
type, just as if the programmer specified the composite type,
the compiler now deduces it.
(this makes more sense with ADTs. however this hasn't been thought
through at all.)

similarly, struct access and tuple access can only be 
resolved at compiletime, however, we could extend it's 
definition to runtime if we conpute the return type 
as a union, or tagged union, or ADT of all struct members.

